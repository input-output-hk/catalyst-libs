//! # Sparse Merkle Tree Module
//!
//! This module provides a wrapper around the `sparse_merkle_tree` crate, offering a
//! simplified interface for working with Sparse Merkle Trees (SMTs) along with additional
//! functionality for tree analysis and batch processing.
//!
//! ## What is a Sparse Merkle Tree?
//!
//! A Sparse Merkle Tree is a cryptographic data structure that represents a key-value
//! store as a binary tree. Unlike traditional Merkle trees, SMTs are designed to handle
//! extremely large key spaces efficiently by only materializing nodes that are actually
//! neededâ€”nodes on paths to non-empty leaves. All other nodes are implicitly zero, making
//! the tree "sparse."
//!
//! For example, a full binary tree of height 256 would theoretically require 2^256 nodes,
//! which is impossible to store. An SMT with only 100 leaves might materialize only a few
//! hundred nodes while still providing the same cryptographic guarantees.
//!
//! ## Core Type: `Tree<V>`
//!
//! The [`Tree<V>`] struct is a generic wrapper that works with any value type `V` that
//! implements `Default`, `Value`, and `Clone`.
//!
//! ### Basic Operations
//!
//! **Creating a new tree:**
//! ```ignore
//! let mut tree = Tree::<MyValueType>::new();
//! ```
//!
//! **Inserting values:**
//! ```ignore
//! let key = tree.insert(my_value)?;
//! ```
//! Keys are automatically generated by hashing the value's byte representation.
//!
//! **Retrieving values:**
//! ```ignore
//! let value: Option<MyValueType> = tree.get(&key)?;
//! ```
//!
//! **Generating Merkle proofs:**
//! ```ignore
//! let proof = tree.merkle_proof(&[key1, key2, key3])?;
//! ```
//!
//! **Getting the Merkle root:**
//! ```ignore
//! let root_hash = tree.root();
//! ```
//!
//! **Checking tree state:**
//! ```ignore
//! let is_empty = tree.is_empty();
//! let leaf_count = tree.count();
//! ```
//!
//! ## Extended Functionality
//!
//! This wrapper provides two additional methods not typically found in standard SMT
//! implementations:
//!
//! ### `coarse_height()`
//!
//! Returns an appropriate height level for grouping Merkle tree nodes into batches. This
//! is useful for operations that need to process the tree in chunks or levels, with the
//! granularity automatically adjusted based on the tree size.
//!
//! ### `horizontal_slice_at()`
//!
//! Returns an iterator over a complete horizontal slice of the tree at the specified
//! height, including both materialized and virtual nodes.
//!
//! ## Re-exported Types
//!
//! The module re-exports two types from the underlying `sparse_merkle_tree` crate:
//!
//! ```ignore
//! pub use sparse_merkle_tree::{MerkleProof, H256};
//! ```
//!
//! ### Why re-export instead of wrap?
//!
//! **`H256`:** This is a simple 32-byte hash type (essentially a byte array wrapper).
//! Creating another layer of abstraction would add no value and only complicate the API.
//! Direct use of the underlying type is more ergonomic.
//!
//! **`MerkleProof`:** This is a complex type with intricate internal structure containing
//! proof paths, sibling nodes, and other cryptographic data. Wrapping it would require
//! re-implementing substantial functionality and maintaining API compatibility.
//! Re-exporting allows users to leverage the full capabilities of the underlying
//! implementation without duplication.
//!
//! ## Performance Considerations
//!
//! - **Lazy iteration:** [`Tree::horizontal_slice_at()`] returns an iterator rather than
//!   collecting all values upfront, allowing on-demand processing and early termination.
//!   This is crucial for heights near the leaves where the theoretical width can be
//!   enormous (e.g., 2^200 positions).

pub use error::Error;
pub use tree::Tree;
pub use value::Value;

mod error;
mod hasher;
mod tree;
mod utils;
mod value;
